/*
 * OpenSSH Vulnerability Checker
 * Author: Yitzhak B. Solorzano
 * 
 * This program scans specified IP addresses or network ranges to check if the
 * servers are running a potentially vulnerable version of OpenSSH. It checks
 * if the SSH port (default is 22) is open, retrieves the SSH banner, and 
 * determines if the server is running a version known to have vulnerabilities.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <netdb.h>

#define BUFFER_SIZE 1024
#define TIMEOUT 2

typedef struct {
	char	*ip;
	int 	port;
	char	*status;
	char	*message;
} Result;

void	*check_vulnerability(void *arg);
int	is_port_open(const char	*ip, int port);
char	*get_ssh_banner(const char *ip, int port);

int main(int argc, char *argv[]) {
	if(argc < 2) {
		fprintf(stderr, "Usage: %s <targets> [--port<port>]\n", argv[0]);
		return (1);
	}
	int 	port = 22;
	for(int i = 2; i < argc; i++) {
		if(strcmp(argv[i], "--port") == 0 && i + 1 < argc) {
			port = atoi(argv[++i]);
		}
	}
	int 	total_scanned = 0, closed_ports = 0;
	char 	*not_vulnerable[argc - 1], *vulnerable[argc - 1];
	int	nv_count= 0, v_count = 0;
	pthread_t	threads[argc -1];
	Result results[argc - 1];

	for(int i = 1; i < argc && strcmp(argv[i], "--port") != 0; i++) {
		results[i-1].ip = argv[i];
		results[i-1].port = port;

		pthread_create(&threads[i-1], NULL, check_vulnerability, &results[i-1]);
		total_scanned++;
	}
	for (int i = 0; i < total_scanned; i++) {
		pthread_join(threads[i], NULL);

		if (strcmp(results[i].status, "closed") == 0) {
			closed_ports++;
		} else if (strcmp(results[i].status, "vulnerable") == 0) {
			vulnerable[v_count++] = results[i].message;
		} else if (strcmp(results[i].status, "not_vulnerable") == 0) {
			not_vulnerable[nv_count++] = results[i].message;
		}
	}

	printf("\nðŸ›¡ï¸ Servers not vulnerable: %d\n", nv_count);
	for (int i = 0; i < nv_count; i++) {
		printf("   [+] Server at %s\n", not_vulnerable[i]);
	}

	printf("\nðŸš¨ Servers likely vulnerable: %d\n", v_count);
	for (int i = 0; i < v_count; i++) {
		printf("   [+] Server at %s\n", vulnerable[i]);
	}

	printf("\nðŸ”’ Servers with port 22 closed: %d\n", closed_ports);
	printf("\nðŸ“Š Total scanned targets: %d\n", total_scanned);

	return 0;
}

void *check_vulnerability(void *arg) {
	Result *result = (Result *)arg;
	if (!is_port_open(result->ip, result->port)) {
		result->status = "closed";
		result->message = "Port closed";
		return NULL;
	}

	char *banner = get_ssh_banner(result->ip, result->port);
	if (strstr(banner, "SSH-2.0-OpenSSH") == NULL) {
		result->status = "failed";
		result->message = banner;
		return NULL;
	}

	char *vulnerable_versions[] = {
		"SSH-2.0-OpenSSH_8.5p1", "SSH-2.0-OpenSSH_8.6p1",
		"SSH-2.0-OpenSSH_8.7p1", "SSH-2.0-OpenSSH_8.8p1",
		"SSH-2.0-OpenSSH_8.9p1", "SSH-2.0-OpenSSH_9.0p1",
		"SSH-2.0-OpenSSH_9.1p1", "SSH-2.0-OpenSSH_9.2p1",
		"SSH-2.0-OpenSSH_9.3p1", "SSH-2.0-OpenSSH_9.4p1",
		"SSH-2.0-OpenSSH_9.5p1", "SSH-2.0-OpenSSH_9.6p1",
		"SSH-2.0-OpenSSH_9.7p1"
	};

	for (int i = 0; i < sizeof(vulnerable_versions) / sizeof(vulnerable_versions[0]); i++) {
		if (strstr(banner, vulnerable_versions[i]) != NULL) {
			result->status = "vulnerable";
			result->message = result->ip;
			return NULL;
		}
	}

	result->status = "not_vulnerable";
	result->message = result->ip;
	return NULL;
}

int is_port_open(const char *ip, int port) {
	int sockfd;
	struct sockaddr_in addr;

	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0) {
		perror("socket");
		return 0;
	}

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	inet_pton(AF_INET, ip, &addr.sin_addr);

	struct timeval timeout;
	timeout.tv_sec = TIMEOUT;
	timeout.tv_usec = 0;

	setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

	if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
		close(sockfd);
		return 0;
	}

	close(sockfd);
	return 1;
}

char *get_ssh_banner(const char *ip, int port) {
	int sockfd;
	struct sockaddr_in addr;
	static char buffer[BUFFER_SIZE];

	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0) {
		perror("socket");
		return "Failed to create socket";
	}

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	inet_pton(AF_INET, ip, &addr.sin_addr);

	struct timeval timeout;
	timeout.tv_sec = TIMEOUT;
	timeout.tv_usec = 0;

	setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

	if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
		close(sockfd);
		return "Failed to connect";
	}

	int len = recv(sockfd, buffer, BUFFER_SIZE - 1, 0);
	if (len < 0) {
		close(sockfd);
		return "Failed to receive data";
	}

	buffer[len] = '\0';
	close(sockfd);

	return buffer;
}

